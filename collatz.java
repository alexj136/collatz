import java.util.ArrayList;
class Main {
    public static void main(String[] args) {
        Rule rule = null;
        if (args[0].equals("CollatzRule"))
            rule = CollatzRule.INSTANCE;
        else if (args[0].equals("ThreeRule"))
            rule = ThreeRule.INSTANCE;
        else {
            System.out.println("Invalid rule name");
            System.exit(1);
        }
        final int limit = Integer.parseInt(args[1]);
        System.out.println(new IntGraph(rule).iterateRange(limit));
    }
}
/*
 * Represents a graph of integers generated by an iterative process given by
 * a function (the Rule field).
 */
class IntGraph extends ArrayList<RulePair> {
    // TODO: Think about whether this can be optimised for large graphs by
    // sorting the list.
    public final Rule rule;
    public IntGraph(Rule rule) { this.rule = rule; }
    public void iterateFrom(int value) { iterateFrom(value, -1); }
    public void iterateFrom(int value, int iterationLimit) {
        if (value < 1) throw new IllegalArgumentException();
        RulePair pair = new RulePair(value, rule);
        while (!contains(pair) &&
                (iterationLimit == -1 ? true : iterationLimit-- > 0)) {
            add(pair);
            pair = new RulePair(pair.output, rule);
        }
    }
    public IntGraph iterateRange(int value) { return iterateRange(value, 1); }
    public IntGraph iterateRange(int startValue, int endValue) {
        if (startValue > endValue) {
            int tmp = startValue;
            startValue = endValue;
            endValue = tmp;
        }
        for (int i = startValue; i <= endValue; i++)
            iterateFrom(i);
        return this;
    }
    @Override
    public String toString() {
        String                     out  = "digraph G {" + "\n";
        for (RulePair pair : this) out += "    " + pair + "\n";
        return                     out +  "}"                 ;
    }
}
class RulePair {
    public final int input;
    public final int output;
    public RulePair(int input, int output) {
        this.input = input;
        this.output = output;
    }
    public RulePair(int input, Rule rule) {
        this(input, rule.apply(input));
    }
    @Override
    public String toString() {
        return input + " -> " + output;
    }
    @Override
    public boolean equals(Object other) {
        return ((RulePair) other).input == input;
    }
}

abstract class Rule {
    protected Rule () {}
    public abstract int apply(int value);
}
/*
 * The rule for the Collatz Conjecture.
 * - if n % 2 == 0, successor is n/2
 * - if n % 2 == 1, successor is n*3 + 1
 */
class CollatzRule extends Rule {
    public static final CollatzRule INSTANCE = new CollatzRule();
    private CollatzRule() {} 
    public int apply(int value) {
        return (value % 2) == 0 ? value / 2 : (3 * value) + 1;
    }
}
/*
 * A different iteration rule.
 * - if n % 3 == 0, successor is n/3
 * - if n % 3 == 1, successor is n*2 + 1
 * - if n % 3 == 2, successor is n*2 + 2
 */
class ThreeRule extends Rule {
    public static final ThreeRule INSTANCE = new ThreeRule();
    private ThreeRule() {} 
    public int apply(int value) {
        return   (value % 3) == 0 ?    value / 3
             :   (value % 3) == 1 ?    (2 * value) + 1
             : /* value % 3  == 2 ? */ (2 * value) + 5;
    }
}
