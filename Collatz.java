import java.util.ArrayList;
public class Collatz {
    public static void main(String[] args) {
        final int limit = Integer.parseInt(args[0]);
        IntGraph ig = new IntGraph(new CollatzRule());
        for (int i = 1; i <= limit; i++)
            ig.iterateFrom(i);
        System.out.println(ig);
    }
}
/*
 * A rule that generates an int from an int, such as the rule in the Collatz
 * Conjecture.
 */
abstract class Rule {
    public abstract int computeNext(int value);
    public RulePair compute(int value) {
        return new RulePair(value, computeNext(value));
    }
}
/*
 * The rule for the Collatz Conjecture.
 */
class CollatzRule extends Rule {
    public int computeNext(int value) {
        return (value % 2) == 0 ? value / 2 : (3 * value) + 1;
    }
}
/*
 * Represents a graph of integers generated by an iterative process given by
 * a function (the Rule field).
 */
class IntGraph extends ArrayList<RulePair> {
    // TODO: Think about whether this can be optimised for large graphs by
    // sorting the list.
    public final Rule rule;
    public IntGraph(Rule rule) { this.rule = rule; }
    public void iterateFrom(int value) { iterateFrom(value, -1); }
    public void iterateFrom(int value, int iterationLimit) {
        RulePair pair = rule.compute(value);
        while (!contains(pair) &&
                (iterationLimit == -1 ? true : iterationLimit-- > 0)) {
            add(pair);
            pair = rule.compute(pair.output);
        }
    }
    @Override
    public String toString() {
        String                     out  = "digraph G {" + "\n";
        for (RulePair pair : this) out += "    " + pair + "\n";
        return                     out +  "}"                 ;
    }
}
class RulePair {
    public final int input;
    public final int output;
    public RulePair(int input, int output) {
        this.input = input;
        this.output = output;
    }
    @Override
    public String toString() {
        return input + " -> " + output;
    }
    @Override
    public boolean equals(Object other) {
        return ((RulePair) other).input == input;
    }
}
/*
 * Visualize a different graph:
 * - if n % 3 == 0, successor is n/3
 * - if n % 3 == 1, successor is n*2 + 1
 * - if n % 3 == 2, successor is n*2 + 2
 */
class ThreeRule extends Rule {
    public int computeNext(int value) {
        return   (value % 3) == 0 ?    value / 3
             :   (value % 3) == 1 ?    (2 * value) + 1
             : /* value % 3  == 2 ? */ (2 * value) + 5;
    }
}
